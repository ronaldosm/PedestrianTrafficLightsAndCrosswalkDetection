import torch
import math

def find_angle_from_coord(coordinates_list,IScrosswalk_list):
    """
    Find crosswalk inclination. Inputs: Coordinates list, IScrosswalk values
    """
    thetas = []
    for coordinates,IScrw in zip(coordinates_list,IScrosswalk_list):
        if IScrw: thetas.append(math.atan2(coordinates[3]-coordinates[1],coordinates[0]-coordinates[2])*180/3.14159)
    return thetas


def find_crosswalk_len(coordinates_list,IScrosswalk_list):
    """
    Find crosswalk length. Inputs: Coordinates list, IScrosswalk values
    """
    len_arr = []
    for coordinates,IScrw in zip(coordinates_list,IScrosswalk_list):
        if IScrw: len_arr.append(float(((coordinates[3]-coordinates[1])**2+(coordinates[0]-coordinates[2])**2)**(1/2)))
    return len_arr


def distance(Mcoord,Tcoord,Tcrw):
    """
    Calculate the mean and STD values of the distance between the ground-truth and the predicted crosswalk coordinates. Inputs: Model coordinates, Ground-truth coordinates, IScrosswalk values. Outputs: start-point distance, start-point STD, endpoint distadef accuracy(confusion_matrix):
    correct_pred = sum(confusion_matrix[i][i] for i in range(len(confusion_matrix)))
    return correct_pred/sum(sum(x) for x in confusion_matrix)


def overall_accuracy(Mi,Ti,Ml,Tl):
    correct_pred = 0
    for mi,ti,ml,tl in zip(Mi,Ti,Ml,Tl):
        if round(float(mi)) == int(ti) and round(float(ml)) == int(tl): correct_pred += 1
    return correct_pred/len(Ti)nce, endpoint STD.
    """
    start_vec,end_vec = [],[]
    for [Mx1,My1,Mx2,My2],[Tx1,Ty1,Tx2,Ty2],IScrw in zip(Mcoord,Tcoord,Tcrw):
        if IScrw != 0:
            start_vec.append(float(((Tx1-Mx1)**2+(Ty1-My1)**2)**0.5))
            end_vec.append(float(((Tx2-Mx2)**2+(Ty2-My2)**2)**0.5))

    start_dist= sum(start_vec)/len(start_vec)
    end_dist  = sum(end_vec)/len(end_vec)

    start_std = ((sum([(Di-start_dist)**2 for Di in start_vec]))/len(start_vec))**0.5
    end_std   = ((sum([(Di-end_dist  )**2 for Di in end_vec  ]))/len(end_vec  ))**0.5

    return start_dist,start_std,end_dist,end_std


def confusion_matrix(model_classes,true_classes,n_classes):
    assert n_classes >= 2, 'At least 2 classes are needed'
    M = torch.FloatTensor([[0]*n_classes]*n_classes)
    for Mc,Tc in zip(model_classes,true_classes): M[int(Tc)][round(float(Mc))] += 1
    return M


def class_accuracy(confusion_matrix):
    correct_pred = sum(confusion_matrix[i][i] for i in range(len(confusion_matrix)))
    return correct_pred/sum(sum(x) for x in confusion_matrix)


def overall_accuracy(Mi,Ti,Ml,Tl):
    correct_pred = 0
    for mi,ti,ml,tl in zip(Mi,Ti,Ml,Tl):
        if round(float(mi)) == int(ti) and round(float(ml)) == int(tl): correct_pred += 1
    return correct_pred/len(Ti)


def precision_recall(confusion_matrix):
    precision = []
    recall = []
    for i in range(len(confusion_matrix)):
        col_sum = sum(confusion_matrix[i][:])
        row_sum = sum([row[i] for row in confusion_matrix])

        if row_sum: precision.append(float(confusion_matrix[i][i]/row_sum))
        else: precision.append(0.0)
        if col_sum: recall.append(float(confusion_matrix[i][i]/col_sum))
        else: recall.append(0.0)

    if len(confusion_matrix) == 2: return precision[1],recall[1]
    else: return precision,recall
